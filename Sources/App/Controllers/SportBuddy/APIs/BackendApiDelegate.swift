import Vapor
// BackendApiDelegate.swift
//
// Generated by vapor-server-codegen
// https://github.com/thecheatah/SwiftVapor-swagger-codegen
// Template Input: /APIs.Backend


public enum chatEntriesDeleteResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum chatEntriesGetResponse: ResponseEncodable {
  case http200([ChatDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum chatEntriesPatchResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum chatEntriesPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum chatEntriesPutResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum chatPutResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum exerciseDeleteResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum exerciseGetResponse: ResponseEncodable {
  case http200([ExerciseDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum exercisePostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum exercisePutResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum forgotPasswordPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupEntriesDeleteResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupEntriesGetResponse: ResponseEncodable {
  case http200([GroupDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupEntriesPatchResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupEntriesPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupEntriesPutResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupManagingDeleteResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupManagingGetResponse: ResponseEncodable {
  case http200([GroupDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupManagingPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupPutResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum loginPostResponse: ResponseEncodable {
  case http200(UserResponseDTO)
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum logoutPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum registerPostResponse: ResponseEncodable {
  case http200(UserResponseDTO)
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum searchUserPostResponse: ResponseEncodable {
  case http200([UserDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum testGetResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}

public protocol BackendApiDelegate {
  associatedtype AuthType
  /**
  DELETE /chatEntries
  Delete a chat message */
  func chatEntriesDelete(with req: Request, asAuthenticated user: AuthType, chatEntryDTOId: UUID) throws -> EventLoopFuture<chatEntriesDeleteResponse>
  /**
  GET /chatEntries
  Get a chat's messages */
  func chatEntriesGet(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<chatEntriesGetResponse>
  /**
  PATCH /chatEntries
  Undo message deletion */
  func chatEntriesPatch(with req: Request, asAuthenticated user: AuthType, chatEntryDTOId: UUID) throws -> EventLoopFuture<chatEntriesPatchResponse>
  /**
  POST /chatEntries
  Send a chat message */
  func chatEntriesPost(with req: Request, asAuthenticated user: AuthType, chatId: UUID, message: String) throws -> EventLoopFuture<chatEntriesPostResponse>
  /**
  PUT /chatEntries
  Modify a chat message */
  func chatEntriesPut(with req: Request, asAuthenticated user: AuthType, chatEntryDTOId: UUID, modifiedMessage: String) throws -> EventLoopFuture<chatEntriesPutResponse>
  /**
  PUT /chat
  Update a chat */
  func chatPut(with req: Request, asAuthenticated user: AuthType, chatId: UUID, body: String?, users: [UUID]?) throws -> EventLoopFuture<chatPutResponse>
  /**
  DELETE /exercise
  Delete an exercise */
  func exerciseDelete(with req: Request, asAuthenticated user: AuthType, exerciseId: UUID) throws -> EventLoopFuture<exerciseDeleteResponse>
  /**
  GET /exercise
  Get the exercises */
  func exerciseGet(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<exerciseGetResponse>
  /**
  POST /exercise
  Post an exercises */
  func exercisePost(with req: Request, asAuthenticated user: AuthType, body: ExerciseDTO) throws -> EventLoopFuture<exercisePostResponse>
  /**
  PUT /exercise
  Modify an exercise */
  func exercisePut(with req: Request, asAuthenticated user: AuthType, body: ExerciseDTO) throws -> EventLoopFuture<exercisePutResponse>
  /**
  POST /forgotPassword
  Send a recovery email to an existing user of the application or an admin */
  func forgotPasswordPost(with req: Request, email: String) throws -> EventLoopFuture<forgotPasswordPostResponse>
  /**
  DELETE /groupEntries
  Delete a group message */
  func groupEntriesDelete(with req: Request, asAuthenticated user: AuthType, groupEntryDTOId: UUID) throws -> EventLoopFuture<groupEntriesDeleteResponse>
  /**
  GET /groupEntries
  Get a group's messages */
  func groupEntriesGet(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<groupEntriesGetResponse>
  /**
  PATCH /groupEntries
  Undo message deletion */
  func groupEntriesPatch(with req: Request, asAuthenticated user: AuthType, groupEntryDTOId: UUID) throws -> EventLoopFuture<groupEntriesPatchResponse>
  /**
  POST /groupEntries
  Post a group message */
  func groupEntriesPost(with req: Request, asAuthenticated user: AuthType, groupId: UUID, message: String) throws -> EventLoopFuture<groupEntriesPostResponse>
  /**
  PUT /groupEntries
  Modify a group message */
  func groupEntriesPut(with req: Request, asAuthenticated user: AuthType, groupEntryDTOId: UUID, modifiedMessage: String) throws -> EventLoopFuture<groupEntriesPutResponse>
  /**
  DELETE /groupManaging
  Leave group */
  func groupManagingDelete(with req: Request, asAuthenticated user: AuthType, groupId: UUID) throws -> EventLoopFuture<groupManagingDeleteResponse>
  /**
  GET /groupManaging
  Get the list of groups */
  func groupManagingGet(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<groupManagingGetResponse>
  /**
  POST /groupManaging
  Join a group */
  func groupManagingPost(with req: Request, asAuthenticated user: AuthType, groupId: UUID) throws -> EventLoopFuture<groupManagingPostResponse>
  /**
  PUT /group
  Update a group */
  func groupPut(with req: Request, asAuthenticated user: AuthType, groupId: UUID, body: String?, users: [UUID]?) throws -> EventLoopFuture<groupPutResponse>
  /**
  POST /login
  Login an existing user of the application or an admin */
  func loginPost(with req: Request, email: String, password: String) throws -> EventLoopFuture<loginPostResponse>
  /**
  POST /logout
  Logout an existing user of the application or an admin */
  func logoutPost(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<logoutPostResponse>
  /**
  POST /register
  Register a new user in the application */
  func registerPost(with req: Request, name: String, email: String, password: String) throws -> EventLoopFuture<registerPostResponse>
  /**
  POST /searchUser
  Search a user */
  func searchUserPost(with req: Request, asAuthenticated user: AuthType, name: String) throws -> EventLoopFuture<searchUserPostResponse>
  /**
  GET /test
  Test */
  func testGet(with req: Request) throws -> EventLoopFuture<testGetResponse>
}
