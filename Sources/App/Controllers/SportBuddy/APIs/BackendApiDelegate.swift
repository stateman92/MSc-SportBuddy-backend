import Vapor
// BackendApiDelegate.swift
//
// Generated by vapor-server-codegen
// https://github.com/thecheatah/SwiftVapor-swagger-codegen
// Template Input: /APIs.Backend


public enum chatDeleteResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum chatGetResponse: ResponseEncodable {
  case http200([ChatDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum chatPatchResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum chatPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum chatPutResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum exerciseDeleteResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum exerciseGetResponse: ResponseEncodable {
  case http200([ExerciseDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum exercisePostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum exercisePutResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum forgotPasswordPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupDeleteResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupGetResponse: ResponseEncodable {
  case http200([GroupDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupManagingDeleteResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupManagingGetResponse: ResponseEncodable {
  case http200([GroupDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupManagingPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupPatchResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum groupPutResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum loginPostResponse: ResponseEncodable {
  case http200(UserResponseDTO)
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum logoutPostResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum registerPostResponse: ResponseEncodable {
  case http200(UserResponseDTO)
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum searchUserPostResponse: ResponseEncodable {
  case http200([UserDTO])
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum testGetResponse: ResponseEncodable {
  case http200
  case http400

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http400:
      let response = Response()
      response.status = HTTPStatus(statusCode: 400)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}

public protocol BackendApiDelegate {
  associatedtype AuthType
  /**
  DELETE /chat
  Delete a chat message */
  func chatDelete(with req: Request, asAuthenticated user: AuthType, chatEntryDTOId: UUID) throws -> EventLoopFuture<chatDeleteResponse>
  /**
  GET /chat
  Get a chat's messages */
  func chatGet(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<chatGetResponse>
  /**
  PATCH /chat
  Undo message deletion */
  func chatPatch(with req: Request, asAuthenticated user: AuthType, chatEntryDTOId: UUID) throws -> EventLoopFuture<chatPatchResponse>
  /**
  POST /chat
  Send a chat message */
  func chatPost(with req: Request, asAuthenticated user: AuthType, chatId: UUID, message: String) throws -> EventLoopFuture<chatPostResponse>
  /**
  PUT /chat
  Modify a chat message */
  func chatPut(with req: Request, asAuthenticated user: AuthType, chatEntryDTOId: UUID, modifiedMessage: String) throws -> EventLoopFuture<chatPutResponse>
  /**
  DELETE /exercise
  Delete an exercise */
  func exerciseDelete(with req: Request, asAuthenticated user: AuthType, exerciseId: UUID) throws -> EventLoopFuture<exerciseDeleteResponse>
  /**
  GET /exercise
  Get the exercises */
  func exerciseGet(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<exerciseGetResponse>
  /**
  POST /exercise
  Post an exercises */
  func exercisePost(with req: Request, asAuthenticated user: AuthType, body: ExerciseDTO) throws -> EventLoopFuture<exercisePostResponse>
  /**
  PUT /exercise
  Modify an exercise */
  func exercisePut(with req: Request, asAuthenticated user: AuthType, body: ExerciseDTO) throws -> EventLoopFuture<exercisePutResponse>
  /**
  POST /forgotPassword
  Send a recovery email to an existing user of the application or an admin */
  func forgotPasswordPost(with req: Request, email: String) throws -> EventLoopFuture<forgotPasswordPostResponse>
  /**
  DELETE /group
  Delete a group message */
  func groupDelete(with req: Request, asAuthenticated user: AuthType, groupEntryDTOId: UUID) throws -> EventLoopFuture<groupDeleteResponse>
  /**
  GET /group
  Get a group's messages */
  func groupGet(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<groupGetResponse>
  /**
  DELETE /groupManaging
  Leave group */
  func groupManagingDelete(with req: Request, asAuthenticated user: AuthType, groupId: UUID) throws -> EventLoopFuture<groupManagingDeleteResponse>
  /**
  GET /groupManaging
  Get the list of groups */
  func groupManagingGet(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<groupManagingGetResponse>
  /**
  POST /groupManaging
  Join a group */
  func groupManagingPost(with req: Request, asAuthenticated user: AuthType, groupId: UUID) throws -> EventLoopFuture<groupManagingPostResponse>
  /**
  PATCH /group
  Undo message deletion */
  func groupPatch(with req: Request, asAuthenticated user: AuthType, groupEntryDTOId: UUID) throws -> EventLoopFuture<groupPatchResponse>
  /**
  POST /group
  Post a group message */
  func groupPost(with req: Request, asAuthenticated user: AuthType, groupId: UUID, message: String) throws -> EventLoopFuture<groupPostResponse>
  /**
  PUT /group
  Modify a group message */
  func groupPut(with req: Request, asAuthenticated user: AuthType, groupEntryDTOId: UUID, modifiedMessage: String) throws -> EventLoopFuture<groupPutResponse>
  /**
  POST /login
  Login an existing user of the application or an admin */
  func loginPost(with req: Request, email: String, password: String) throws -> EventLoopFuture<loginPostResponse>
  /**
  POST /logout
  Logout an existing user of the application or an admin */
  func logoutPost(with req: Request, asAuthenticated user: AuthType) throws -> EventLoopFuture<logoutPostResponse>
  /**
  POST /register
  Register a new user in the application */
  func registerPost(with req: Request, name: String, email: String, password: String) throws -> EventLoopFuture<registerPostResponse>
  /**
  POST /searchUser
  Search a user */
  func searchUserPost(with req: Request, asAuthenticated user: AuthType, name: String) throws -> EventLoopFuture<searchUserPostResponse>
  /**
  GET /test
  Test */
  func testGet(with req: Request) throws -> EventLoopFuture<testGetResponse>
}
